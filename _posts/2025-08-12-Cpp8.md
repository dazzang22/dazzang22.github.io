---
layout: single
title: "Section 8"
categories: cpp
tag: [cpp]
---

```markdown
### 💟 {{1}}. 매개변수와 실 인자의 구분
- 매개변수란? 영어로 parameter
- 실 인자란? 영어로 argument 
### 💟 {{2}}. 값에 의한 인수전달 call by value
- 함수에 값을 넣었을 때 어떠한 과정으로 전달이 되는가?
- 함수의 매개변수의 주소와 호출한곳의 실 인자의 주소는 당연히 다르긬
- 실인자가 전달되는거 ㄴㄴ 일단 갓이 전달되어 복사가일어나 파라미터에 복사
- x+1 이런것도 변수가 아니라 값임
### 💟 {{3}}. call by reference
- reference 로 받으면 함수에서 바꾼 값이 반영되노요.
- 함수는 한번에 하나의 리턴값이 있긔. 근데 여러개를 리턴받고싶을수 잇은
- 그럴때 call by reference 를 사용
- 입력은 const int& 로, 출력은 그냥 &로 지정
- 리터럴은 참조에의한전달이 안되긔 왜? 주소가 없으니까
- 해결법이 2가지가 잇은.
- 벡터도 가능 배열도 가능
### 💟 {{4}}. 주소에 의한 인수 전달
- 주소로 전달도 가능
- 방법이 2가지가 잇은
- 포인터로 구현가능 
### 💟 {{5}}. 다양한 반환값들 - 값, 참조, 주소, 구조체, 튜플
- 함수 리턴으로 포인터 -> 2가지 선택지가 있음
- 1번 : int *value 로 주솟값 받기*
- 2번 : *getValue(3); 이런 식으로 dereferencing된 값 받기 권장 ㄴㄴ해
- reference return 도 됨, address return 도 됨
- return 값이 여러개일때 방법이 2가지가 잇은      

### 💟 {{6}}. 인라인 함수 
- 인라인 함수란? 선언법
### 💟 {{7}}. 함수 오버로딩 - 동일이름 
- 오버로딩의 조건 : parameter가 달야함
- 모호한 경우 회피 방법 : 명시적 캐스팅, 자료형 표기
- typedef를 쓴다고 회피가 되는건 아님. 컴파일 타임에 결정하기 때무니긬
- 회피법 3가지가 잇은.
### 💟 {{8}}. Default parameters 매개변수의 기본값
- 헤더에 함수 선언 시 매개변수는 헤더에서 정의하는게 보통이긴 함
- default 값은 오른쪽부터 채워줘야함. 중간만 채우고 그런거 ㄴㄴ해 
- 오버로딩이랑 겹치면 모호할수잇은 
### 💟 {{9}}. 함수 포인터
- 함수 포인터 = 함수의 주소를 담는 포인터.
- 주 용도: 함수를 인자로 넘길 때, 실행할 함수를 런타임에 선택할 때.
- 꼭 필요한가? → C++11 이후엔 std::function, 람다`로 대체 가능. 하지만 옛 코드나 성능 최적화 상황에선 여전히 쓰임.
### 💟 {{10}}. 스택과 힙
- 이론
### 💟 {{11}}. std::vector 스택처럼 사용하기
- new 와 delete느림 그래서 vector를 잘쓰는법은 어케하며 이걸 최소화할지 생각하면서 ㄱㄱ하는거
- size와 capacity 가 잇은
- resize 시 사실 shrink 를 하는것이 아니놐ㅋ. 속도를 빨리할라고 줄인척한거긔
- 확인해보는 코드를 써보시게나
- reserve는 필수아닌데 하면 개빠름
- 단점도 잇은.
### 💟 {{12}}. 재귀적 함수호출
- // 함수를 호출할땐 함수의 주소로 호출하거든!!!!
- 종료 조건으 ㄹ반드시 필료료료료ㅛ료료룔
- 너무 많이 recursion 하면 stack overflowwwwwww
- stack overflow가 두려운가 . . .?
- 그럼 std::vector 를 reserve 해서 stack 처럼 쓰는 방법도 잇은
### 💟 {{13}}. 방어적 프로그래밍의 개념
- Syntax Error: 문법 오류 (컴파일 자체가 안 됨).
- Semantic Error: 문법은 맞지만 의미적으로 잘못된 경우 (예: 메시지랑 조건 불일치).
- Violated Assumption (가정 위반): 프로그램이 전제한 조건을 사용자가 깨버리는 입력 → 예를 들어 ix에 너무 큰 값 주면 잘못된 메모리 접근 발생. / 해결방법 몇개 제시
### 💟 {{14}}. 단언하기 assert
- 놀라운사실 : assert는 release 모드로 바꾸면 작동안하긔
- const 쓰면되는데 왜 assert씀?
### 💟 {{15}}. 명령줄 인수 
### 💟 {{16}}. 생략부호 ellipsis
```

# 🎓 섹션 {{8}}. {{함수}}



---

### 📌매개변수와 실 인자의 구분

매개변수 :  parameter  

함수가 어떤 기능을 하는지 조절, 변경해주는 기능

실 인자: argument 

'actual parameter' 라고도 함.

함수를 이용하면 argument 가 함수의 parameter로 전달이 된다!



### 📌 값에 의한 인수전달 (Call by Value)

```cpp
void doSomething(int y){
    cout << "y:" << y << endl;
}

int main(){
    int x = 6;
    doSomething(x);
    return 0;
}
```

위의 코드와 같이 `x`라는 변수의 **값을** 직접 함수의 파라미터로 전달하는 방식을 `Call by Value` 라고 한다.

매커니즘 : `x`가 직접 전달되는 것이 아닌 `x`에 들어있는 6이라는 값이 파라미터로 전달되어 `y`로 복사가 되는 것!  

당연히 `&x` 와 `&y`의 값은 다르게 찍힌다.

- `x+1` 이런것도 변수가 아니라 **값**임



### 📌 참조에 의한 인수전달 (Call by Reference)

```c++
void addOne(int x) {
	cout << "Function : " << x << " " << &x << endl; 
	x += 1; 
}

void addOne2(int& x) {
	cout << "Function : " << x << " " << &x << endl; 
	x += 1; 
}

int main(){
    int x = 5;
    addOne(x);
    cout << x << endl;	// x = 5
    addOne2(x);
    cout << x << endl;  // x = 6
}
```

`addOne()` 을 실행했을때, x에 +1 한 사항이 반영이 안되었지만, `addOne2()` 실행 후 반영됨을 알 수 있다.

Why ? 참조(reference) 에 의한 전달 덕분에! ➡️reference 로 받으면 함수에서 바꾼 값이 반영

##### 다중 return 

하나의 함수에는 하나의 리턴값이 있다. 그런데 여러개의 return 값이 필요하다면?

➡️ Call by Reference 를 이용

```c++
void gerSinCos(const double &degrees, double& sinValue, double& cosValue) {
	static const double PI = 3.14159265358979323846; 
	double radians = degrees * (PI / 180.0); 
	sinValue = sin(radians); // Calculate sine
	cosValue = cos(radians); // Calculate cosine
}
```

위의 함수와 같이 입력은 const int& 로, 출력은 그냥 &로 지정해주면 다중 return 값도 가능~

> 지금 함수 안에서 안바뀜 ➡️ CONST 로 줘도 됨
> C++ 에서는 하나의 리턴값➡️ PARAMETER를 많이 두는 경향이 있음
> 그래서 보통은 **앞쪽** 파라미터 : **입력** / **뒷쪽** 파라미터 : **출력** 이런구조
> 헷갈리니까 입력은 **CONST로 힌트를 주**는 경향이있다~! const가없고 레퍼런스구나- 출력

##### 리터럴과 참조

리터럴은 참조에 의한 전달이 안된다. 왜? 주소가 없으니까.

```c++
void foo1(const int& x) {
	cout << "In foo1: " << x << " " << &x << endl;
}

foo1(8);
```

해결법 1 : 위의 코드와 같이 const 로 받는다.

해결법 2 : 함수에서 &를 제거 (ㅋㅋ)

##### 다양한 전달법

포인터, 정적 배열, 벡터 모두 가능하다.

```c++
typedef int* pint; 
void foo(pint &ptr)
void printArray(const int (&arr)[5]
void printVector(const vector<int>& vec)
```

정적 배열을 보낼 때에는 **꼭** element 개수를 넣어서 보내야 한다! (그래서 잘안쓰임;;)



### 📌주소에 의한 인수 전달 ( Call by Address )

```c++
void foo(const int* ptr, int *arr, int length){}

int main(){
    int value = 5;
    foo(&value);
    
    int *ptr = &value;
    foo(ptr);
}
```

Call by Address에는 2가지 방법이 있다!

방법 1 : 주소 직접 넣기 

방법 2 : 포인터 선언 후 포인터 넣기

`foo(5)` 와 같은 리터럴은 당.연.히 안된다. 왜? 주소가 없으니까.

##### 다중 return 값

Call by Reference 에서 실습한 다중 return 값을 똑같이 Call by Address로 구현 가능하다.

```c++
void foo1(double degrees, double *sin, double *cos){
    // dereferencing 후 값변경
    *sin = 1.0;
    *cos = 2.0;
}

foo1(degrees, &sin, &cos);
```

사실 `Call by Address` 는 값에 의한 전달이다. 포인터 변수의 주소가 다르기 때문.

참조에 의한 전달과 달리, 포인터로 **주소를 넘겨**준다!



### 📌다양한 반환값들 - 값, 참조, 주소, 구조체, 튜플

앞서서 인수 전달 방식에 대해 살펴봤다면 이제는 return값에 대한 고찰을 해보잨

*함수 앞에 명시한 리턴타입과 실제 리턴 타입은 같아야 한다!* 

##### return type : 포인터

1번 방법 : int * 로 주솟값 받기

```c++
int* getValue(int x) {
    int value = x * 2;
    return &value;
}

int *value = getValue(3);
```

2 번 방법 : dereferencing된 값 받기 ( 권장 절대 NONONONO )

```c++
 int value = *getValue(3);
```

위와 같은 코드의 문제점 : getValue() 라는 함수 블럭이 끝나서 소멸된 후 이를 dereferencing하려고 하고있음;;

##### return type : 참조

```c++
 int &value2 = getValue2(5);

 cout << value2 << endl;
```

문제 상황 : 받는 쪽에서도 reference 로 받아버리면 안됨.
이유 : 함수에서 받아온 return 값인데 함수 block이 끝나버림 ➡️ 주소에 접근할 수 없음!
그런 상태에서 참조를 하게되면 메모리해지 - garbage val이 . . .

##### return type : 다중 리턴값

Call by Reference 가 아닌 리턴값으로 여러 값을 받고싶다면!! 방법은 2가지

방법 1 : Struct 사용 

```c++
s getStruct() {
    s my_s{1,2,3,4};
    return my_s; // 구조체를 리턴할 때는 값으로 리턴됨, 복사 생성자 호출됨
}
```

단점 : 오버헤드가 크다.

방법 2 : 튜플 사용

```c++
std::tuple<int, double> getTuple() {
    int a = 10;
    double b = 3.14;
    return std::make_tuple(a,b);
}
std::tuple<int, double> my_tuple = getTuple();
cout<< std::get<0>(my_tuple) << endl;

// C++17부터는 구조화된 바인딩을 사용하여 튜플의 값을 쉽게 추출할 수 있음
// a,b 를 선언하면서 값을 받아온거임
auto [a, b] = getTuple(); // C++17부터 지원하는 구조, auto로 타입 추론 가능
```



### 📌인라인 함수 

> 인라인 함수란?
>
> 컴파일러가 함수 호출을 최적화하여 함수의 코드를 호출하는 곳에 직접 삽입하는 기법

```c++
inline int min(int x, int y){
    return x < y ? y : x;
}
```

위의 코드와 같이 `inline` 이라는 키워드를 사용해서 선언한다!

➡️강제 변환이 아니라 권장...? 컴파일러가 인라인 함수를 최적화할 수 있는 경우에만 적용~

요즘은 컴파일러가 인라인으로 넣으면 빨라지겠네~ 하는 함수 알아서 인라인 처리한다구 함><



### 📌함수 오버로딩 - 동일이름 

오버로딩이란?

**같은 이름의 함수를 여러 개 정의할 수 있는 기능**.

단, **매개변수의 개수나 타입이 달라야 함**.

컴파일러가 **호출할 때 인자의 타입과 개수를 보고** 어떤 함수를 쓸지 자동으로 골라줌.

```c++
int add(double x, double y) {
    return x + y;
}

double add(double x, double y) {
	return x + y;
}
```

참고로 이 두개는 Overriding 이 아니다! 

왜 ? return 타입이 다르다고 해서 오버라이딩이 될 수 없다 ➡️ 파라미터 개수, 타입이 달라야 함

오버라이딩 회피하는 방법 : 

1. 그냥 포기하고 이름 변경
2. 그냥 파라미터를 다르게 
3. `void`쓴 후 참조로 받아오자

- typedef를 쓴다고 회피가 되는건 아님. 컴파일 타임에 결정하기 때무니긬

##### 오버로딩 모호성(ambiguity) 문제

```c++
void print(const char* value) {}
void print(unsigned int value) {}
void print(float value) {}

print("a");       // const char* → OK
print('a');       // char → unsigned int? float? 모호 ❌
print(0);         // int → unsigned int? float? 모호 ❌
print(3.141592);  // double → float? ❌
```

해결법 ➡️ 명시적 캐스팅

```c++
print((unsigned int)'a');
print(0u);
print(3.141592f);
```

- **오버로딩 선택은 전부 컴파일 시점에 결정됨** (런타임 아님).
- 따라서 인자 타입이 애매하면 반드시 캐스팅으로 의도를 명확히 해야 함.



### 📌 Default parameters - 매개변수의 기본값

보통은!! 헤더에 함수 선언 시 매개변수는 헤더에서 정의한다.

왜 ? 한눈에 보기 편하니까

- default 값은 오른쪽부터 채워줘야함. 중간만 채우고 그런거 ㄴㄴ해

```c++ 
// 이런 코드는 ㄴㄴ해
void print(int x = 0, int y = 0, int z) {
    cout << x << endl;
}
```

- 오버로딩이랑 겹치면 모호할 수 있다.☠️

```c++
void print2(int x){}
void print2(int x, int y = 10){}

// ambiguous
print2(10);
```



### 📌 함수 포인터

c++ 에는 함수포인터 라는 type 이 있다!! 

문법 : 리턴타입 (*포인터변수명)(매개변수 타입, 없으면 그냥괄호)

함수 포인터란?

함수의 주소를 저장하는 포인터

```c++
int (*funcptr)() = func; 
funcptr();
```

➡️위의 코드는 return 타입이 int 이고, 매개변수가 없는 함수의 주소를 저장하는 포인터

```c++
cout << funcptr << endl;
```

➡️ ()를 붙이지 않고 위와 같이 코드 실행 시 함수의 주소가 출력됨

```c++
funcptr = goo;
```

➡️위와 같이 중간에 함수 교체 가능

주 용도: 함수를 인자로 넘길 때, 실행할 함수를 런타임에 선택할 때.

꼭 필요한가? → C++11 이후엔 std::function, 람다`로 대체 가능. 하지만 옛 코드나 성능 최적화 상황에선 여전히 쓰임.



### 📌std::vector 스택처럼 사용하기

##### 1. `vector`의 특징

- 동적 배열 컨테이너 → 내부적으로 `new/delete` 로 메모리를 관리.
- 하지만 `new/delete` 는 느리므로, **최대한 메모리 재할당을 줄이는 방식**으로 사용하는 게 핵심.

##### 2. `size` 와 `capacity`

- **size**: 현재 들어있는 원소 개수.
- **capacity**: 실제로 할당된 메모리 크기.

##### 3. `reserve()` 와 `resize()`

- `reserve(n)` : capacity 를 **n 이상으로 미리 확보** → 이후 push_back 시 메모리 재할당을 줄여 효율적. ( 필수는 아님 주의 !, 해두면 속도차이가 엄청나긴 함 . . )
  - 단점: 너무 크게 잡으면 메모리 낭비.
- `resize(n)` : size 를 **n으로 변경**. 원소가 줄면 잘린 척만 하고 실제 메모리는 줄이지 않음.

##### 4. `data()`

- `v.data()` → 내부 배열의 포인터 반환.
- C 스타일 포인터처럼 접근 가능 (`ptr[i]`).
- 하지만 `size` 범위 외 접근은 위험 → **런타임 에러 가능**.

```c++
v.resize(2);

// runtime error
// cout << v[2] << endl;
// cout << v.at(2) << endl; 
int* ptr = v.data();

cout << ptr[2] << endl;
```

➡️ 위의 코드를 이용해 vector 가 사이즈 shrink 시 사이즈를 줄이는 척만 하는걸 확인 가능!

##### 왜 Stcak 를 Vector 로 구현하는가?

reserve 를 해 두면 new delete 를 할 필요가 없어서 효율이 좋다!

단점 :  reserve 를 너무 크게 해두면 메몰이 낭비



### 📌재귀적 함수 호출

함수를 호출할땐 함수의 주소로 호출하거든!!!!

- 종료 조건으 ㄹ반드시 필료료료료ㅛ료료룔
- 너무 많이 recursion 하면 stack overflowwwwwww
- stack overflow가 두려운가 . . .?
- 그럼 std::vector 를 reserve 해서 stack 처럼 쓰는 방법도 잇은



### 📌방어적 프로그래밍의 개념
- Syntax Error: 문법 오류 (컴파일 자체가 안 됨).
- Semantic Error: 문법은 맞지만 의미적으로 잘못된 경우 (예: 메시지랑 조건 불일치).

```c++
if (x >= 5) // 메세지는 '초과'인데 실제 코드는 '이상'
    cout << "x is greater than 5" << endl;
```

* Violated Assumption (가정 위반): 프로그램이 전제한 조건을 사용자가 깨버리는 입력 → 예를 들어 ix에 너무 큰 값 주면 잘못된 메모리 접근 발생. 

```c++
int ix;
cin >> ix;

cout << hello[ix] << endl;
```

➡️ 해결법 : while 문으로 true 계속 검사하기 / if 문으로 검사하기 등 . . .



### 📌 단언하기 assert

##### `assert` 란?

- `<cassert>` 에 정의된 매크로.
- **조건이 거짓(false)일 경우 프로그램을 즉시 중단**시키고 에러 메시지 출력.
- 디버그 시점에서 버그를 조기에 발견하는 데 사용.

##### 문법

```c++
assert(condition);
```

- 놀라운사실 : assert는 release 모드로 바꾸면 작동안함 ➡️ debug 모드에서만 동작

#####  `static_assert`

런타임 체크가 무섭다면? 컴파일 타임에 체크하면 그만이야~

- `assert` 는 **런타임** 체크.
- `static_assert` 는 **컴파일 타임** 체크.
- 조건이 거짓이면 **컴파일 자체가 실패**함.

```c++
int x = 5;
static_assert(x == 5, "x should be 5");
```

위 코드는 error code 이다!!

왜? `const int` 로 선언해야 하니까.

왜? 컴파일 타임에 고정된 변수여야 검사가 되니까

왜? 런타임에 변경될 가능성이 있으니까



### 📌명령줄 인수 

명령줄 인수는 프로그램 실행 시에 전달되는 인수들이다.
`argc`는 인수의 개수를 나타내고, `argv`는 각 인수를 문자열로 저장하는 배열이다.

```c++
int main(int argc, char *argv[])
{
    for (int i = 0; i < argc; ++i) {
		std::cout << "Argument " << i << ": " << argv[i] << std::endl;
	}
}
```

##### 명령줄 인수 실행법

1번째 방법

1. Visual Studio에서 프로젝트 속성 열기 **( Property )**
2. "디버그" 탭 선택 **( Debugging )**
3. "명령줄 인수" **( Command Argument )** 필드에 인수를 입력 (예: "arg1 arg2 arg3") 

2번째 방법 
1. 2022 검색해서 프롬프트 열기
2. 프로젝트 폴더로 이동
3. 컴파일: cl Chapter7_15.cpp
4. 실행: Chapter7_15.exe arg1 arg2 arg3



### 📌생략부호 ellipsis

#####  `...` (ellipsis) 이란?

함수 인자 개수를 고정하지 않고, **임의 개수의 인자**를 받을 수 있음.

C 스타일 방식 (`<cstdarg>` 사용).

함수 선언 예:

```c++
double findAverage(int count, ...);
```

→ `count` 개수만큼 뒤에 오는 인자를 처리.

#####  

##### `<cstdarg>` 주요 매크로

`va_list` : 가변 인자들을 담는 타입.

`va_start(list, last_fixed_arg)` : 가변 인자 시작 위치 초기화.

`va_arg(list, type)` : 인자 하나를 읽어옴. (타입 반드시 지정해야 함).

`va_end(list)` : 사용 끝내기 (자원 정리).



##### 예제

```c++
double findAverage(int count, ...) {
    double sum = 0;
    va_list list;

    va_start(list, count);
    for (int i = 0; i < count; ++i) {
		sum += va_arg(list, int);
	}
    va_end(list);

	return sum / count;
}

// count 이후에는 검사를 안함
cout << findAverage(3, 1, 2, 3, "Hello", "c") << endl;
// 오류남~ 개수 맞춰줘야해 그래서 값이 크면 쓰레기값이 옴
cout << findAverage(10, 1, 2, 3, 4, 5) << endl;
```

놀라운 점 : `findAverage(3, 1, "Hello", "c")` 이래도 실행이 됨 ➡️ error가 나지 않는다

C++에서는 위험하므로 잘 안 쓰이고, 대신에 **템플릿 함수 / 가변 템플릿 인자(pack)** 를 사용함.
