---
layout: single
title: "Pointer"
categories: cpp
tag: [cpp]
---

# 포인터, 앙딱정



## 1. C++ 에서 Pointer 란?

> 포인터란 ?  [메모리의 주소] 를 저장하는 type이다.

###### 참고로 지역 변수는 Stack memory를, 동적 할당 메모리는 heap memory 를 사용.

#### 왜 포인터를 쓰는가?

가장 큰 이유는 Array 때문이라 할 수 있겠다.

- 우린 Array 를 다룰 때, 함수 파라미터로 배열을 넣으면 배열이 복사됨을 알고있다.

  ➡️ 당연히 ! 속도가 느려지고 for문이라도 돌면 큰 사고 발생

- 그래서 포인터로 배열 시작 주소와 element수를 넘겨주면, 복사하지 않고 원본 배열을 다룰 수 있다! ➡️ 이때 배열시작 주소를 포인터에 복사하게 되어 복사가 1회 일어남

  - 참조라는 것이 더 자주쓰이긴 한다.

##### 포인터 선언 및 사용법

```c++
int *x = &y;
```

포인터는 주소 저장 변수이므로 주소값을 넣어줘야 한다.

##### 다변수포인터 선언 시 주의사항

```c++
int *ptr_1 = &x, ptr_2 = &y;
```

위와 같이 선언하게 되면 `ptr_2`는 포인터가 아니게 된다! (`*ptr_2`로 써야함)

그렇기 때문에 `typedef int* pint` 이런 식으로 `typedef`하는 것을 선호한다.

```c++
typedef int* pint;
pint ptr_1 = &x, ptr_2 = &y;
```

또한, 이중/삼중 포인터 사용 시 typedef를 사용하면 좋다.

```c++
int x = 10;
// 비추천 방식
int *ptr_1 = &x;
int **ptr_2 = &ptr_1;

//추천 방식
typedef int* pint;
pint ptr_1 = &x;
pint* ptr_2 = &ptr_1;
```

##### de-referencing 의 개념

de-referencing 이란 ? 포인터 변수에 저장된 **주소의 값(value)** 을 불러온다.

de-referencing operator 인 `*` 를 사용한다.

```c++
int x = 10;
int *ptr = &10;

cout << *ptr << endl;
```

출력 결과 : `10`

이처럼 `*` operator는 주소에 **저장된 값**을 불러온다.

```c++
// *ptr 과 *&x 는 같은 뜻이다.
cout << *&x << endl;
```

**`*(&)` 를 하면 동일한 결괏값을 얻을 수 있다~!**

##### 포인터 type 에 관한 주의사항

**포인터의 타입**은 **변수의 타입**과 **동일**해야 오류가 나지 않는다.

```c++
double x = 1.0;
doulbe *ptr = &x;
```

위와 같이 주솟값으로 넣을 변수의 type 과 포인터의 type는 동일해야 한다.

> 왜 ? de-referencing 할 경우, 불러올 값의 type을 지정해야 하기 때문.

##### 포인터 변수의 사이즈

```c++
int x = 10;
int *ptr = &x;

cout << sizeof &x << " " << sizeof ptr << endl;
```

위의 코드를 실행시켜보면 x64 에서는 8, x86 에서는 4byte가 출력된다.

➡️ &x와 ptr은 모두 주소를 저장하기 때문에 사이즈가 같음!

**x64**에서는 주소를 저장하는데에 **더 많은 메모리**를 쓰기 때문에 크기가 더 크다.

> 포인터 그 자체는 **고유 사이즈**를 갖고 불변임을 명심.

##### 구조체와 포인터

> 구조체 포인터는 왜쓰는가? 
>
> 구조체 크기가 클 때, 값을 그대로 복사해서 함수에 전달하면 **메모리와 시간이 낭비**

```c++
struct Person{
    int age,
    double height;
};

int main(){
    Person person1;
    Person *ptr_s;
    
    cout << sizeof person1 << endl;
    cout << sizeof ptr_s << endl;
}
```

`sizeof`를 찍어보면 `person1`은 선언한 **구조체의 크기**가, `ptr_s`은 **포인터변수의 크기**(x64 기준 8Byte) 가 나온다.

유의사항 : 구조체 포인터는 **초기화가 필수**다. ➡️ 안하면 빌드도 안되긴함ㅋ

Question : 포인터는 주소저장 변수니까 **주소 복붙해서 넣**으면 안됨?
- 네 허용 안해줍니다. 아예 안되는건 아니고 이게 해킹의 원리임.

## 2. NULL POINTER

##### 선언 방법

```c++
double *ptr1 = 0;			// c - style
double *ptr2 = NULL;		
double *ptr3 = nullptr;		// c++11 이후 사용가능
```

- 널포인터가 왜중요한지 말해보시긔
- 함수의 파라미터로 포인터를 받는게 잇은. 이때 파라미터로 &주소를 넣어줘도 잘 작동함.
- nullptr_t 라는 키워드가 잇은.
- 포인터변수자체의 주소도 찍어볼수잇은. 파라미터로 들어간거의 주소도 찍어볼수잇은

## 3. 메모리 동적 할당 new 와 delete

`memory leak` (메모리 누수)를 파악할 수 있는 방법 (참고)

➡️task manager 를 띄우고 메모리 사용량을 지켜보기

우리는 **정적으로 할당**받는 메모리는 **stack** 에 저장됨을 알고 있다. ➡️ stack은 빠르지만 **용량이 매우 작다**. ( stack overflow 위험이 있음 )

```c++
int array[100000];
```

위와 같이 memory 가 많이 필요한 경우, 동적 할당을 고려해보자.

➡️OS로 부터 받아온 메모리의 주소에 포인터를 저장하는 로직이다.

```c++
int* ptr = new (std::nothrow) int{ 7 };

// 사용 . . .

delete ptr;
```

☠️다른 프로세스가 메모리를 다써버려서 할당 ㄴㄴ 인경우가 있다.☠️

`new` 는 보통 메모리 부족 시 `std::bad_alloc` 예외를 던진닷.

그런데 `std::nothrow` 를 붙이면 할당 실패 시 예외를 안 던지고 `nullptr` 을 반환!

☠️사실 new delete는 속도가 느리다.☠️ 

그렇기 때문에 최소화하는 방향으로 나아가야 함.



**주의할 점**

```c++
int *ptr = new int{7};
int *ptr2 = ptr;

delete ptr;
ptr = nullptr;

cout << *ptr2 << endl;
```

null ptr 를 de referencing하면 오류가 난다...!

➡️그래서 전 강의에서 배웠던 nullptr을 써야함. if nullptr 체크 필수☠️



## 4. 포인터와 const

5가지 case를 같이 살펴보자.

##### Case 1 : 변수가 const 인경우

```c++
const int val = 5;
const int* ptr = &val;
```

포인터도 const int * 형을 사용해야 포인터에 `val`의 주소를 할당할 수 있다.

➡️즉, `ptr` 은 cosnt int를 가리키는 포인터인 셈!

- dereferencing 을 해서 값을 바꾸는건 안된다. ➡️ **이 포인터는 읽기 전용이다.**
- 그러나 놀랍게도 포인터의 주소 교체는 가능하다. **포인터변수 자체**는 const가 아니니깐
- de referencing 해서 값 읽기는 당여니 가능

```c++
cout << *ptr << endl;	//됨
*ptr = 6;	// 안됨☠️☠️☠️

const int val2 = 8;
ptr = &val2;	//됨
```

##### Case 2 : 포인터만 const 인 경우 

```c++
int val = 5;
const int* ptr = val;
```

읽기전용 포인터이기 때문에 당여니 de referencing 해서 값을 바꾸는건 안된다. 

근데 바꾼 값을 읽는건 가능.

```c++
val = 10;
cout << *ptr << endl;	// 결과 : 10
```

##### Case 3 : 2번case 에서 주소 교체

당연니 됨. 1번 케이스를 보시라

```c++
int val = 5;
const int* ptr = &val;

int val2 = 10;
ptr = &val2;
```

➡️ 아무 문제 x

##### Case 4 : 포인터변수 자체가 const

포인터 변수 자체가 const인 경우이기 때문에 주솟값을 바꿀 수 없다.

```c++
int value = 5;
int* const ptr = &value;
```

해당 코드는 int 형을 읽는 const 포인터이다.

```c++
*ptr = 6;
```

 dereferencing 가능하다. 

```c++
int value2 = 10;
ptr = &value2;	// 이건 안됨!!!!!☠️☠️☠️☠️
```

> 주솟값을 변경할 수 없다.
>
> 왜? 포인터 자체가 const 니깐

##### Case 5 : 포인터도 cosnt고 포인터변수 자체도 const 

```c++
int value = 5;
const int* const ptr5 = &value;
```

➡️dereferencing도 안되고 주소도 못바꾸미 ㅋ

## 5. Void Pointer

원래는 포인터와 넣으려는 변수 자료형 같아야 오류가 안난다. 

그러나 void 는 암고나 넣어도 작동한다!

```c++
int i = 5;
float f = 3.0;

void *ptr = nullptr;
ptr = &f;
```

> 그래서 포인터 연산이 안된다.
>
> `ptr+1`같은 포인터 연산은 자료형을 알아야 가능하기 때문.

```c++
cout << ptr << endl;
//cout << *ptr << endl; -> 안됨
```

물론! 주소를 찍어보는 것은 가능하다.

➡️ dereferencing 은 안됨☠️

**할 수 있는 방법이 있긴 하다. static casting한 후 다시 de reference하면 가능!**

```c++
cout << *static_cast<float*>(ptr) << endl;
```

- 최근에는 일케 까지 않하긴헤
