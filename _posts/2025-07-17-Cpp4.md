---
layout: single
title: "Section 4"
categories: cpp
tag: [cpp]
---



```markdown
### 🧠 {{1}}. 핵심 요약
- 연산자 우선순위 in cpp
- 연산자 종류 간략하게 ( 단항연산자, 이항연산자, 삼항연산자, 관계 . . )
### 🧠 {{2}}.핵심 요약
- 딱히 없슨
### 🧠 {{3}}.핵심 요약
- 없슨
### 🧠 {{4}}.핵심 요약
- sizeof()는 왜 함수가 아니지? 사용법 2가지
- comma operator 란? 언제 잘 씀?
- conditional operator(arithmetric if)란? 문법 말해보게나
- conditional operator 언제 유용 (const) / 언제 별로? ( 조건복잡, 리턴타입 다름 )
- conditional operator if문으로 치환해보시긔
### 🧠 {{5}}.핵심 요약
- 관계연산자 종류 6가지 
- 부동소수점 비교 시 오차가 생기는 이유 말해보시게 -> 실수형 비교 시 주의~
- 해결법 코드를 너가 써보시게
- std :: abs () 뭔쓰임새고 뭐 include 해야하는지 위에 묶어서 말하시게
### 🧠 {{6}}.핵심 요약
- c++ 에는 없는 논리연산자는?ㅋ
- c++에선 놀랍게도 논리연산자에 순위가 있다 ... ! 뭐게~
- 항상 권장하는 방법 괄호를 치시게.
- 논리곱 and 에서 조건 뒤 검사안하는 경우 
### 🧠 {{7}}.핵심 요약
- 이진수 
### 🧠 {{8}}.핵심 요약
- 비트연산자 종류를 나열하시게 
- 비트연산 시 권장되는 자료형은? 왜 ㅋ?
- 비트 확인법 및 어떤 함수를 사용하는지?
- 비트연산도 줄여쓸 수 있다 . . !
- xor 연산자가 존재함
- 비트연산을 왜 쓰는가 특히 shift는 왜
- shift 의 기능 및 10진수 계산법
### 🧠 {{9}}.핵심 요약
- 예를 들어 flag 가 너무 많으면 if 문이 길어지고 가독성이 떨어짐
- array를 더 욱 컴팩트하게 쓸 수 있는 방법은 ? 비트플래그
- 비트플래그를 초기에 설정하는 법 코드로 써보시게
- 아이템 1이 들어왓사 -> or
- 아이템 1이 빠졋어 -> ^xor 연산도되는거아냐? 확인해보자
- 아이템 있는지 확인 -> &
- 아이템 여러개 들어왓슨 -> 여러개 or
- 비트 마스크 쓰임새 말해보시게 
- 마스크 설정법 코드로 
- rgb 예제에서 shift 를 왜했지? 무슨 문제를 해결하려고 했지?
- bitset 자세히 알아보자.

```

# 🎓 섹션 {{4}}. {{연산자}}

연산자에 대한 내용

---

### 📌연산자 우선순위와 결합법칙

- 연산자의 종류에는 **단항, 이항, 비트, 논리, 조건, 대입, 나열 연산자** 가 있슨.
- C++에서의 연산자 우선순위는 다음과 같다.

| 순위 | 연산                                                 | 방향 |
| :--: | :--------------------------------------------------- | :--: |
|  1   | 괄호                                                 |  ➡️   |
|  2   | **단항** 연산자 ( ! ~ + - 부호 sizeof --expr ++expr) |  ⬅️   |
|  3   | *, / , %                                             |  ➡️   |
|  4   | +, -                                                 |  ➡️   |
|  5   | **shift 연산 <<, >>**                                |  ➡️   |
|  6   | 논리 연산자  ( <, <=, >, >=)                         |  ➡️   |
|  7   | 논리연산자 **(!=, ==)**                              |  ➡️   |
|  8   | 비트연산자 **&**                                     |  ➡️   |
|  9   | 비트연산자 **^**                                     |  ➡️   |
|  10  | 비트연산자 \|                                        |  ➡️   |
|  11  | 조건 연산자 **&&**                                   |  ➡️   |
|  12  | 조건 연산자 **\|\|**                                 |  ➡️   |
|  13  | 삼항연산자 ( ?  : )                                  |  ⬅️   |
|  14  | 대입 연산자 =                                        |  ⬅️   |
|  15  | **comma operator (,)**                               |      |

### 📌산술 연산자 및 증감 연산자

* 산술 연산자* / % + -
* 증감연산자
  * prefix : ++expr / --expr ➡️ 증감 후 사용
  * suffix : expr++ / expr-- ➡️ 사용 후 증감

### 📌sizeof(), comma operator, conditional operator

- **sizeof()** 는 C++가 정의하기를,  **연산자** 이다! 
  - `sizeof a`와 같이 **괄호 없이**도 쓸 수 있다.
  - sizeof(자료형) / sizeof(변수명) ➡️ 둘다 동작한다 ㄷㄷ
- comma operator 는 - *따로 문서 만들기*
  - **두개 이상의 표현식(expression)** 을 한줄에 나열
  - 마지막 표현식의 결과만 반환
  - **for 루프**에서 많이 쓰임 
  - 너무 남발하면 **가독성**이 떨어질 수 있음!

- conditional operator(arithmetric if)는 **삼항연산자** 라고도 한다.
  - `(조건) ? a : b;`의 꼴을 갖는다.
  - **const 형 초기화** 시 유용하다!
  - 반면, 조건식이 너무 복잡하거나 리턴타입 (a,b) 이 다르면 **비추~** 


### 📌관계 연산자

- 관계연산자는  (true/false)를 반환하는 연산자이다.
  - ==, !=,>,<,>=,<= 6가지이다.

- 실수 비교 시 **오차**가 생기는 이유
  - 컴퓨터는 실수를 **2진 부동소수점**으로 근사해서 저장하기 때문에, **정확한 비교가 어려워 오차가 발생**한다!

- 부동소수점 오차를 해결하는 법

  ```C++
  #include <cmath>
  
  int a1, a2;
  int epsilon = 1e-15;
  
  if(std::abs(a1-a2) < epsilon)
      // something . . .
  ```

  이와 같이 <cmath> 의 `std::abs`를 사용하여 오차를 계산하고, 그 값이 사용자 설정 오차허용 한계값(epsilon)보다 작은 경우 같다고 본다.  

### 📌논리 연산자 

* c++ 에는 논리곱 and (&&) 와 논리곱 or (||) 가 있다.
* c++ 에는 XOR 연산자가 없다!
* c++에선 놀랍게도 논리연산자에 순위가 있다 .
  * **logical AND** 가 logical OR 보다 **우선순위가 높**다.
  * `true||false && true` 는 `true||(false && true)` 와 같이 계산된다!
  * 그렇기 때문에 권장하는 방법 -> **괄호**를 치시게.
* 논리곱 and 에서 조건 뒤 **검사 안하는** 경우 : 앞 조건이 **이미 false** 인 경우 뒤의 조건 skip

### 📌비트 연산자 

- 비트연산자는 총 6종류로, (<< >> & | ^ ~) 가 있다.

  - `^` : XOR 연산을 하는 연산자
  - shift 연산과 나머지 비트 논리 연산자는 우선 순위가 다르다!
    - shift 가 더 높음ㅋ

- 비트연산 시 unsigned int 를 사용하는 것이 권장된다. 

- 10진수 -> 2진수 비트 가시화 방법 

  ```c++
  #include <bitset>
  
  unsigned int a = 3;
  cout << std::bitset<4>(a) << endl;
  ```

  std::bitset<표현할 비트 수>(변수명) 과 같이 사용하여 2진수 표현을 가시적으로 확인가능

- 비트연산도 줄여 쓸 수 있다 . . !

  - HOW ? `c &=d;`, `c|=d;`, `c^=d;` `c~=d;`, `c=<<2;`, `c=>>;`

- shift 연산 (<< >>)의 쓰임새

  - **왼쪽 시프트** (`a >> n`)
     ➡️ 비트를 왼쪽으로 n칸 이동 → 결과는 `a × 2-ⁿ`
  - **왼쪽 시프트** (`a << n`)
     ➡️ 비트를 왼쪽으로 n칸 이동 → 결과는 `a × 2ⁿ`

- shift 연산의 쓰임새 ( 산술 shift 와 논리 shift 차이 추후 다룸 )

  - CPU는 곱셈/나눗셈보다 shift를 훨씬 빠르게 처리한다!
  - 비트 마스크 처리 및 플래그 체크에 사용

### 📌비트 마스크









---



##  더 깊이 보고 싶은 주제

-[]()



(각 링크는 따로 정리한 심화포스터로 연결)



## 생각정리 및 실습 정리 

