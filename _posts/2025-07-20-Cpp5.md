---
layout: single
title: "Section 5"
categories: cpp
tag: [cpp]
---

# 🎓 섹션 {{5}}. {{변수범위}}

변수 범위와 다양한 변수형에 대함.

---

### 📌지역 변수

```c++
int a = 5;

{
    int a = 6;
    cout << "a : " << endl;
}
```

* 위 코드와 같이 더 작은 scope 안에 **동일 변수명**으로 지역변수가 선언될 경우, **`name hiding`**이 일어남 ➡️ 더 큰 scope 의 `a`를 hidding 함.
* scope 는 `{ }` 으로 분리하며, **scope** 가 **끝**나면 그 안의 **지역변수**도 **소멸**한다.

```c++
int a = 1;

void doSomething()
{
	using namespace std;

	int a = 2; // 지역 변수 a
	cout << "a = " << a << endl; // 지역 변수 a를 출력
}

void doSomething()
{
	using namespace std;

	cout << "a = " << a << endl; // 전역 변수 a를 출력
}

```

* 위와 같은 코드는 **컴파일 에러**가 난다. 왜? 같은 함수명이 **conflict** 함.

* 해결 방안이 3개가 있음.

  * 하나를 제거한다.
  * **파라미터**를 다르게 한다. ex) 하나는 `doSomething (int a)` 로 바꾸기 등 
  * **Namespace** 를 이용한다! ➡️`namespace First{ }` 이런 식으로 ~

  ```c++
  int a = 1;
  
  namespace First {
  	void doSomething() {
  		int a = 2; // 지역 변수
  		cout << "First::a = " << a << endl; // 2
  	}
  }
  
  namespace Second {
  	void doSomething() {
  		cout << "Second::a = " << a << endl; // 전역 변수 사용 (1)
  	}
  }
  
  int main() {
  	First::doSomething();
  	Second::doSomething();
  	return 0;
  }
  ```

### 📌Using 문의 모호성

*namespace 주의해야 하는 이유 ➡️ 선언하면 **취소가 안**됨 ! 그 **scope전체**에 **영향**이 있음.*

* **두 개 이상**의 **namespace** 에서 **같은 변수명**을 사용했을 경우, **모호성**이 발생한다.

```c++
namespace a {
    int my_var(20);
}
namespace b {
    int my_var(20)
}
```

- 해결법 1. **블록화**

  - 해당 네임스페이스의 변수가 사용될 부분만 블록으로 묶은 후 블록 내에서 using을 쓴다!

  ```c++
  {
      using naemespace a;
      cout<<my_var<<endl;
  }
  ```

- 해결법 2. **::** 사용

  - ```c++
    cout << "a::my_var = " << a::my_var << endl;
    cout << "b::my_var = " << b::my_var << endl;
    ```

- `using std::cout;` 이런 것도 되긴 함 ➡️ `std::cout`는 **namespace 가 아니므로** using namespace 아님 주의 ~

### 📌전역 변수



### 📌Auto

- Auto 란? ➡️ C++11 부터 도입된 타입 추론 기능이다.

- auto 특징 

  -  **초기화**가 **필수** !!! ➡️ 초기화 안하면 사용 불가
  -  `auto c = 1 + 2.0;` 와 같이 **계산식도** 사용 가능! 
    - ⚠️ 단점 : 계산 결과의 타입이 가시적이지 않음.
  - `auto add(int a, int b) return a + (double)b; ` 처럼 **함수 반환타입**도 Ok
  - **매개변수**엔 **못**쓴다네. W h y? ➡️ **매개변수 : Overloading 은 형 추론과 관계 X** 

- auto 의 **명시적** 지정 방법이 있다.

  - **`auto add(int a, int b) -> double;`** 와 같이 선언 가능
  - 만약 선언부에 `->`를 이용하여 **선언**하였다면 **정의**도 `->` 를 써야 컴파일 에러가 나지 X

  ```c++
  auto add(int a, int b) -> double { return a + static_cast<double>(b); }
  ```



### 📌형 변환

- typeinfo 네임스페이스 안의 typeid()
  - typeid ➡️ C++의 RTTI(런타임 타입 정보) 기능을 사용하여 변수의 타입 정보를 얻는 함수
  - `cout << typeid(a).name() << endl;` 와 같이 `.name()` 로 타입 이름 알 수 o

- 명시적 형변환 - 3가지 style
  - `int a = int(4.0)`➡️C Style
  - `int a = (int)4.0`➡️C++ Style
  - `int a = static_cast<int>(4.0)`➡️ C++ Style

- 암시적 형변환 - 2가지 경우
  - Numeric **Promotion** : 더 작은 타입에서 큰 타입으로 변환 -> 크게 문제 없음
  - Numeric **Conversion** : 큰 타입에서 작은 타입으로 변환 -> 데이터 **손실** 가능성 있음
  - ```c++
    int i = 30000;
    char c = i;
    cout << static_cast<int>(c) << endl;
    ```
  - 위와 같은 경우, char의 범위는 `-127 ~ 128` 이므로 값이 잘려서 저장된다 ... !
  - ```c++
    int i2 = 2;
    char c2 = i2;
    cout << static_cast<int>(c2) << endl;
    ```
  - 위와 같은 경우 2는 범위 내이므로 손실 없이 잘 나옴.



### 📌 String

* String 은 사용자 정의 자료형이다!
  * `<string>` 라는 네임스페이스를 `#include`해야 함.
  * 그렇기 때문에 **암시적 형변환** 기능이 ❌ : string 형은 무조건 " " 를 붙여야 함.

```c++
int age;
cin >> age;
```

`cin >> 변수 ` 을 사용하면 **공백 문자**를 기준으로 끊어서 값을 저장한다!

int 형은 **공백**이 **필요 없**다는 사실을 기억.

만약 입력을 `13 45` 이런 식으로 했을 경우, 변수에는 `13`이 저장되고 버퍼에는 `"45\n"`이 남는다.

➡️이렇게 될 경우, **다음 입력** 시 **버퍼**의 `"45\n"`이 입력 받아진다.

* 그래서 `std::cin.ignore(32767, '\n')`이 필요하다!  

  ```c++
  std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
  // c++ style
  ```

  💟 std::**streamsize** 란 ?  C++에서 스트림 입력/출력에서 사용하는 정수형 타입이다.

  💟보통 **long long** 을 씀 -> 굉장히 큰 값으로, **줄바꿈 문자를 만나기 전 까지 무조건 다 버린다는 뜻**

```c++
 string name;
 std::getline(std::cin, name);
```

String 타입은 공백이 들어갈 수도 있다.

* 그래서 `std::getline(std::cin, 변수명)` 이 필요하다!

  * getline 함수는 엔터치기 전까지 입력을 받는다

* string 객체는 **+ 연산자를 오버로딩**해서 문자열을 연결할 수 있다. ➡️ **append** 라고 함

  * `cout << a + " " + b << endl;`

* 문자열의 길이도 반환할 수 있다.

  ```c++ 
  cout << a.length() << endl;
  ```

  **공백 포함 / '\n' 제외**
  
  

### 📌 자료형에게 가명 붙여주기

```c++
typedef vector<std::pair<std::string, int>> pairlist_t;

pairlist_t pairlist1;
```

* 위와 같이 **길고 복잡**하거나, 특정한 변수들이 **어떠한 종류**인지 **명시**하기 위해 `typedef`를 사용한다.
* `std::int8_t i(97)` 과 같은 고정너비 정수형도 이런 식으로 코딩한 것이다.
* `using pairlist_t = vector<std::pair<std::string, int>>` 과같이 `using`키워드도 사용 가능
* **가시성**이 올라간다



### 📌 구조체 Struct

```c++
struct Person {
	// 구조체의 members : 구조체 안에 정의된 변수들
	double height; // 키
	float weight;  // 몸무게
	int age;       // 나이
	string name;   // 이름
	// 생성자(Constructor) : 객체를 생성할 때 자동으로 호출되는 함수
	Person(double h, float w, int a, string n) 
		: height(h), weight(w), age(a), name(n) {}
	
	void print() {
		cout << "Name: " << name << endl;
		cout << "Height: " << height << " cm" << endl;
		cout << "Weight: " << weight << " kg" << endl;
		cout << "Age: " << age << " years" << endl;
	}
};
```

* **구조체**란 ?  **여러 개의 서로 다른 타입의 변수들을 하나로 묶어서 사용하는 사용자 정의 자료형**

- 파라미터 관리에 용이하다.

- **초기화 주의 사항**

  - struct 안에서 string name = "Dazzang2" 이렇게 **직접 초기화 가능** => **Default** 값
  - 근데 다른 곳에서 사용 시 값을 변경 => 이게 **우선순위가 더 높**기 때문에 이걸 반영

- struct는 **리턴값으로 받**을수도, **파라미터로 넣**을 수도, **struct 안에 다른 struct를 넣**을 수도 있다.

- `sizeof (Person)` 과 같이 `sizeof`를 사용할 수 있다.

  - 주의할 점 : short 등 **padding** 때문에 예측한 사이즈가 아닐 수 있음

  - ######  Padding이란?

    **Padding(패딩)**은 **메모리 정렬(alignment)**을 맞추기 위해 컴파일러가 구조체 멤버 사이에 **빈 공간(더미 바이트)**을 자동으로 삽입하는 것.

    > 💡 CPU가 메모리에 접근할 때 더 빠르고 효율적으로 동작하려면, 데이터가 특정 바이트 단위(예: 4바이트, 8바이트)로 정렬되어 있는 게 유리하기 때문!

* 생성자(Constructor) 는 직접 정의하지 않아도 된다.

  * `Person p1 = {175.5, 65.0f, 30, "홍길동"};` 이런 식으로 생성자 없이 맴버 초기화 가능

  * 근데 왜 쓰는가?

    > 1. 초기화를 강제할 수 있음
    > 2. 초기화 로직을 추가할 수 있음
    > 3. 코드가 더 명확해짐



##  더 깊이 보고 싶은 주제

-[]()



(각 링크는 따로 정리한 심화포스터로 연결)



## 생각정리 및 실습 정리 
