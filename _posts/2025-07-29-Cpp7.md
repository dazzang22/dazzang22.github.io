---
layout: single
title: "Section 7"
categories: cpp
tag: [cpp]
---

```markdown
### 💟 {{1}}. 배열 - Array 기초
- 배열의 사이즈 구하는 법은 자료형크기 * 인덱스 개수이묘
- 초기화는 각각 설정할 수 잇은, 근데 인덱스 넘어가는값 초기화하면 빌드안됨
- 넘어가는값 초기화 안하고 출력해보면 쓰레기값 나오묘
- 구조체도 배열선언 가능 -> 구조체 크기는 안에 선언된 변수들의 자료형크기 총합 
- 구조체 배열 크기 = 구조체 크가 * 인덱스 수
- 구조체 배열 접근방법 : rectangles[0].width 이런 식으로 접근한.
- 초기화 방법 4가지가 잇은. 각각 / 일부만 / c++11 이상 / 모두0
- Enum을 배열 인덱스로 쓸수도잇은 근데 권장 ㄴ So enum class로 묶어버림
- enum 으로 초기화하고 인덱스화 가능 - 장점 : 개수랑 인덱스 일치
- 배열 크기는 컴파일 타임에 고정 -> 가변변수 ㄴㄴ해 const를 넣던가 해야대
- 근데 동적할당을 쓰긴해 
### 💟 {{2}}. 배열 - Array 2
- 배열 이름 자체가 주소로 쓰이묘 
- 배열의 경우 주소연산자 & 를 사용하지 않아도 배열의 시작주소가 찍힌,
- 배열의 시작주소는 [0]주소와 같은ㅋ
- 배열 주소 10진수로 보고싶으면 꼭 (int) 캐스팅 해주시긔
- 배열 주소를 찍어보면 int형은 4바이트라 4씩 커진.
- 함수의 파라미터로 배열을 넣을 수 잇은.
- 파라미터로 전달되는건 배열 그자체가 아니라 포인터임.(주소)
- 차피 포인터로 받아와서 크기는 전달안해도된ㅋㅋ
- 쓰는 방버비 여러개가 잇은.
- 근데 파라미터로 받은 배열 & 찍어보면 뭔 다른 주소가 나오묘 -> 포인터변수의 주소임
- [0] 찌거보면 내가아는 시작주소가 나오노요
- 포인터 변수의 사이즈를 찍어보면 8이찍히노요. 배열이 아니라는 증거라노
### 💟 {{3}}. 배열과 반복문
- arrray 의 사이즈를 구하는 방법이 잇은.
- 파라미터로 넘어간 배열 사이즈는 그 방법으로 구하면 안대노요. 왜? 배열 사이즈 찎어보면 8나오니까. 사실 배열이 아니고 배열포인터 변수의 사이즈가 나오니깐ㅋ
- 파라미터로 그럼 element수까지 보내야 가능ㅋㅋ
### 💟 {{4}}. 배열과 선택 정렬
- 선택정렬이라는 알고리즘이잇은.
- swap 이란게 잇은. 인덱스만 저장해도 ㄱㅊ은거 아시는분
### 💟 {{5}}. 정적 다차원배열
- 잘 안쓰노요
- 0으로 초기화하는 방법이 잇은. 안되는 방법이 잇은.
- 이차원 배열은 내부적으로는 일차원이긴함
- 그건 주소를 찍어보면 증명이 가능하긴해
- row M / column M 가 잇은
- 세마이콜론을 꼭 찍어야하묘, 등호 없는 초기화법도 잇은 c++11
### 💟 {{6}}. 배열 문자열 - c++ 스타일
- String 이란게 잇은. <cstring> 을 씀
- char [] = "" 선언시 sizeof 찍어보면 "안의 글자수" 보다 1개가 더 많이 찍힘
- 왜? 마지막에 안보이는 \0 null char가 잇은
- cout 은 \0만날때까지 출력하는거묘.
### 💟 {{7}}. 포인터 기초 - 따로 문서로 빼야대
- 지역 변수와 동적 할당 메모리는 저장되는 주소의 위치가 다름을 유의
- 주소 출력법, 앧오프 오퍼레이터
- 포인터란게 잇은. 메모리주소를 담는 변수임
- * 의 위치논쟁이 잇은. 그냥 쓸때랑 파라미터로 넘길 때가 잇는데 스타일은 자유긴함
- 다변수 선언 시 포인터 선언 주의해야하묘
- 포인터는 변수의 타입명과 동일해야 오류가 안나노요
- 이중 삼중 포인터 사용 시 typedef사용하면 좋긴함
- de reference 라는 개념이 잇은. * 이건 dereference operator 임
- 포인터의 자료형이 왜 필요하냐면 나중에 deref할때 어떤 타입으로 가져올지.
- typeid 로 확인가능하긴한데 os마다 다르게 뜨묘
- 포인터 변수는 사이즈가 따로 정해져잇은. 불면임.
- 구조체 에도 포인터 사용가능함 -> 크기를 찍어보게나
- 문제점 초기화한하면 ㅈ댐!

### 💟 {{8}}. Null pointer
- 널포인터 선언 방법이 3개가 잇은.
- 널포인터가 왜중요한지 말해보시긔
- 함수의 파라미터로 포인터를 받는게 잇은. 이때 파라미터로 &주소를 넣어줘도 잘 작동함.
- nullptr_t 라는 키워드가 잇은.
- 포인터변수자체의 주소도 찍어볼수잇은. 파라미터로 들어간거의 주소도 찍어볼수잇은
- 두개가 다른 주소 사용. 왜? 복사, 다른 주소 쓴다

### 💟 {{9}}. 포인터와 정적배열
- 신기한 현상이 잇은. char배열인 문자열은 정수형 배열과 출력결과가 다름
- 배열은 곧 주소다라는 사실은 이제 잘 알거심
- 근데 char 형을 찎어보면 주소가 나오는게 아니라 그 문자열 전체가 뜸
- [0]번쨰의 주소를 찍어ㅓ도 그 문자열 전체가 나오묘
- 이건 오버로딩 기능때문임 
- ostream& operator<<(ostream& os, const char* str); 라는게 잇은
- char*을 받으면 그 포인터가 가리키는 null-terminated 문자열을 출력함
- 근데 * 로 받으면 첫번째 문자가 나옴 - 디레퍼런싱
- 그러니까 정리하자면 문자열은 오버로딩으로 인해서 주소 출력이 안됨.
- 정 하고싶으면 (void*) 로 캐스팅해야됨 ㄷㄷ

```

![image-20250729213002017](../images/image-20250729213002017.png)