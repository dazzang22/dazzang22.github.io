---

---

```c++
#include <bits/stdc++.h>
using namespace std;
int main(){
    vector<int> a = {1,2,3};
    sort(a.begin(), a.end());	//정렬 필수
    do{
        for (int i : a) cout << i << " ";
        cout << '\n'
    // next_permutation 은 오름차순으로 작동함
    }while(next_permutation(a.begin(), a.end()));
}
```

do while permutation 을 기억하라

```c++
#include <bits/stdc++.h>
using namespace std;

void f(int n, int r, int depth){
    if (r==depth)
        return;
    for (i=depth;i<n;i++){
        swap(v[i],v[depth]);
        f(n,r,depth+1);
        swap(v[i],v[depth]);
    }
}
```

순열 by recursive function 

logic 
재귀 함수를 호출하면서 내려갔다가 원상복귀하는 logic



조합 by recursive function 

```c++
#include <bits/stdc++.h>
using namespace std;

// 인덱스 기반, 왜? 헷갈리지 않기 위함
void combi(int s, vector<int> v){
    if(v.size()==k)
        return;
    for (int i=s+1; i<n; i++){
        v.push_back(i);
        combi(i+1, v);
        v.pop_back();
    }
    return;
}
```

조합 by 중첩 for 문

```c++
using namespace std;

int n = 5;
int k = 3;

// n개 뽑는거면 n개의 for 문이 중첩으로 들어간다
int main(){
    for(int i = 0; i < n; i++){
        for(int j= 0; j < i; j++){
            for(int k = 0; k < j; k++){
                cout << i << j << k << '\n'
            }
        }
    }
    return 0;   
}
```

C++ 표준 라이브러리에는 `split()` 함수가 내장되어 있지 않음. 그래서  `string::find()`과 `string::substr()`을 직접 사용하여 구현 (엄 ;;)

C++에서 `find` 함수의 반환값은 **찾는 객체의 타입에 따라 다르디.** `std::string::find`는 찾은 문자열의 **시작 위치(index)**를 `size_t` 타입으로 반환하고, `std::find` 알고리즘은 일치하는 **첫 번째 원소의 반복자(iterator)**를 반환하며, 찾지 못했을 경우에는 범위의 마지막을 나타내는 반복자를 반환.

`string::npos`는 C++에서 `std::string` 클래스의 멤버로, **문자열에서 특정 문자열이나 문자를 찾지 못했을 때 반환되는 상수**입니다. 이는 `find()`와 같은 문자열 함수가 검색에 실패했을 때 사용되며, 찾은 문자의 시작 위치를 나타내는 인덱스 대신 사용됩니다. `npos`는 `size_t` 타입의 값을 가지며, 실질적으로는 불가능한 인덱스를 의미하는 매우 큰 양수(일반적으로 `-1`의 unsigned 값)입니다. 

```c++
#include <bits/stdc++.h>
using namespace std;

//split 구현
vector<string> split(const string &input, string delimiter){
    auto start = 0;
    auto end = input.find(delimiter);
    vector<string> result;
    while (end != string::npos){
        result.push_back(input.substr(start, end - start));
        start = end + delimiter.size();
        end = input.find(delimiter, start);
    }
    // npos
    result.push_back(input.substr(start));
    return result;
}
int main(){
    return 0;
}
```

로직 

find로 delimiter 를 찾고 그 지점을 end 로 잡는다 
substr 로 시작위치부터 그 단어의 길이 (end - start)로 추출한다

push 후 start 와 end 의 위치 재조정