---
layout: single
title: "Array"
categories: cpp
tag: [cpp]
---

# Array, 앙딱정



## 1. C++ 에서 Array 란?

지금부터 해당 문서에서 말하는 Array 는 **'정적 배열'** 을 뜻한다.

> Array 란?
>
> '같은' 자료형의 값들을 연속된 메모리 공간에 저장하는 자료구조
>
> ex) int 형 array는 int만, double 형 array에는 double만 저장



## 2. Array 선언 및 초기화

```c++
int myArray[100];
```

크기가 100인 int 형 array 선언. ➡️ 크기 지정은 필수!!

```c++
// 초기화 방법

// 1. 기본형
int myArray[5] = {1,2,3,4,5};
// 2. uniform initialization - C++11 이상
int myArray2[]{1,2,3,4,5};
// 3. zero initialization 
int myArray[4]{};
// 4. 일부만 초기화 -> 초기화하지 않은 나머지는 모두 0
int myArray[5]{1,2};
```

☠️ 주의할 점  

* **0으로 초기화할 때 element 개수 표기가 필수!!**
* 지정한 element개수를 **초과**하여 초기화 ➡️ 허용 안됨



## 3. Array 특징

#### 배열의 사이즈  

=  **sizeof 자료형 ** * **element 개수**



#### 메모리 접근 시 유의사항

```c++
int myArray[4]{};

cout << myArrat[4] <<endl;
```

위와 같이 배열 크기보다 큰 인덱스로 접근하면 **메모리 침범(Out of bounds)** 발생➡️쓰레기값이 나온다.



#### 구조체 배열선언 가능

```c++
struct Person{
    int age;
    idouble height;
}

int main(){
    Person people[7];	// 선언은 일반 배열 선언과 동일
    people[1].age = 6;	// 이런 식으로 구조체 멤버 접근
}
```

> 구조체 크기는 **안에 선언된 변수들의 자료형크기 총합** 이므로 
>
> 구조체 배열 크기 = **구조체 크기 * 인덱스 수**



#### Enum 

아래와 같이 enum을 선언할 때 배열과 관련지어서 생성하면 배열 관리가 쉽다!

```c++
enum StudentName{
    Dazzang1,
    Dazzang2,
    Dazzang3,
    Dazzang4,
    Dazzang5,
    Dazzang6,
    NUM_STUDENTS
}

int main(){
    // enum 의 마지막에 선언 -> 앞서 선언한 member 개수와 인덱스 일치
    int studentScores[NUM_STUDENTS];
    
    // 초기화
    studentScore[Dazzang1] = 90;
    studentScore[Dazzang2] = 45;  
}
```

> Enum을 enum 과 관련없는 배열 인덱스로 쓸수도 있다. ( 일단 숫자니까! )
>
> int myArray{}; 
>
> myArray[Dazzang1] = 100;
>
> ➡️비추 



#### 배열 크기

**컴파일 타임**에 고정됨 ➡️ 가변변수 절대 불허

```c++
int x = 5;
int myArray[x];
```

위와 같이 코드를 짜면 컴파일 에러가 뜬다. 

즉, 정적 배열의 크기지정에 변수를 쓰고싶다면 `const` 를 붙여야 함을 명심하자.

다른 해결방법으로는 **매크로 선언**이 있다 => 근데 **동적할당**을 쓰긴 함. 



### 배열과 포인터

우리는 포인터가 **주소를 저장하는 변수**임을 알고 있다. 

하지만 놀라운 사실! 

> 배열 **이름 자체가 주소**로 쓰인다.
>
> 즉, 배열의 경우, 주소연산자 & 를 사용하지 않아도 **배열의 시작주소**가 찍힌다.
>
> ( & 연산자를 사용하는것도 가능하다. 동일한 값이 찍힘.)

```c++
const int x = 5;
int myArray[x]{};

cout << myArray << endl;
```

위 코드를 실행시켜보면 `myArray[0]` 의 주소가 나온다!

➡️ 배열의 **시작주소**는 **[0]주소**와 같다.



#### 배열의 각 element 주소

우리는 배열을 선언할 때, 자료형을 입력한다.
이 자료형이 배열의 각 element 의 주소를 결정한다.

```c++
int myArray[5];
```

라는 배열이 있고, myArray[0] 의 주소가 10이라 하자.

> 그럼 myArray[1]의 주소는 ? 
>
> ➡️ int 형이기 때문에 4Byte, 즉 4칸 떨어진 14가 된다. 

이처럼 자료형은 **다음 주소를 지정**하는데에 쓰인다.



#### 주소 10진수로 보는 법

배열 주소는 기본적으로 16진수로 출력되는데,10진수로 보고싶으면 꼭 (int) 캐스팅을 해야 한다!

```c++
cout << (int)&x[1] << endl;
```



#### 함수의 파라미터와 배열

```c++
void doSomething(int myArray[5]){
    // do smth
}
```

main 함수에서 `doSomething(myArray);` 를 하면 배열의 **주솟값**이 복사되어 **doSomething()**에 전달된다.

해당 코드에는 사실 함정이 있다.

파라미터로 전달되는건 배열 그자체가 아니라 **포인터**이다! ( 배열 이름은 주소로 쓰이니까 ) 

➡️어차피 포인터로 받아와서 배열의 크기`[5]`는 필요가 없다.

```c++
void doSomething(int *myArray)
void doSomething(int myArray[])
```

위와 같이 다양한 방식으로 배열을 받아올 수 있다.



#### 주의점

- 파라미터로 받은 배열에 & 를 찍어보면 다른 주소가 나온다 -> 포인터변수의 주소임

```c++
void doSomething(int myArray[]){
    // 파라미터로 선언된 myArray라는 포인터 변수의 주소
    cout << (int)&myArray << endl;
    
    // myArray 의 시작주소
    cout << (int)&myArray[0] << endl;
    
    cout << sizeof(&myArray) << endl;
}
```

즉, 함수 파라미터로 받아오는 배열의 주솟값은 myArray[0]의 주소와 동일하지않음

포인터 변수의 사이즈를 찍어보면 8이 찍힌다. 



## 4. 포인터와 정적 배열

```c++
int arr[5] = {1,2,3,4,5};
cout << array << endl;
```

해당 코드의 실행 결과가 주솟값인것은 잘 알고있을 터.

```c++
cout << &arr[0] << endl;
cout << *arr << endl;
```

두 출력의 실행 결과가 같다는것쯤은 이제 잘 안다.

**그런데!!!**

신기한 현상이 있다. char배열인 문자열은 정수형 배열과 출력결과가 다르다.

```c++
char name[] = "dazzang2";
cout << name << endl; 
cout << &name[0] << endl;
```

이론대로라면 `name`이라는 문자열 배열을 출력했을때 실행결과가 주솟값이어야 한다.

```c++
// 실행결과
dazzang2
dazzang2
```

왜????? => 이건 오버로딩 기능때문임 

- ostream& operator<<(ostream& os, const char* str); 라는게 잇은
- char*을 받으면 그 포인터가 가리키는 **null-terminated 문자열**을 출력함
- 근데 * 로 받으면 첫번째 문자가 나옴 - 디레퍼런싱
- 그러니까 정리하자면~ 문자열은 오버로딩으로 인해서 주소 출력이 안됨.
- 정 하고싶으면 **(void*) 로 캐스팅**해야됨 ㄷㄷ

## 5. For Each 문

보통 for each 문은 `auto`키워드와 많이 쓰인다.

또한, 포인터로 구현한 동적배열에서는 쓸 수 없다. ➡️ 쓰고싶다면 vector를 써야 한닷

```c++
// 알고있지? 초기화 안한 부분은 자동으로 0이 된단다!
int fibinacci[18] = {1,1,2,3,5,8,13,21,34,55}

for (auto& number:fibonacci)
    number*=10;
```

> for each 문 안에서 값을 바꾸고싶은 경우 reference로 받아와야 한다.
>
> 왜 ? for each는 별도의 block 이고, `number`에 값이 복사되니까.

```c++
for (const auto number:fibonacci)
    std::cout << number << " ";
```

> for each 문 안에서 값을 변경하고 싶지 않은 경우, `const`로 받아오는 것을 권장한다.
>
> 왜 ? `const auto`로 선언하면 값을 내부에서 변경할 수 없으니까.

```c++
#include <limits>
#include <algorithm>

int max_number = std::numeric_limits<int>::lowest();
for (const auto& number:fibonacci){
    max_number = std::max(max_number, number);
}
```

for each 와 max 함수 조합은 자주 쓰이니 익혀두자.

 std::max(max_number, number)

```c++
vector<int> fibonacci = = {1,1,2,3,5,8,13,21,34,55};
for (auto& number:fibonacci)
    number*=10;
```

정적배열을 vector 로만 바꾸면 사용법은 동일하다.
